= GETTING STARTED WITH CHICAGO BOSS =

Build with "make"

You will need:
* Tokyo Tyrant running a Table database.
* Erlang R13. (Check your version with erlang:system_info(otp_release) ).

Open up boss.config to set your database info and the port you want to run the server on. When you're ready to rock and roll, run ./start-dev.sh in this directory. There will be a lot of PROGRESS REPORTs which look scary but hopefully everything is running smoothly. With this console you can interact directly with the running server. Next, point your browser to:

http://localhost:8001/hello/world

If all is well you will see "Hello, World!" Now you can get busy.


= THE CHICAGO BOSS API: MODEL, VIEW, CONTROLLER, AND DATABASE  =

== The Model Directory: BossRecords ==

BossRecords are specially compiled parameterized modules. Important aspects of BossRecords:

    * The first parameter of a BossRecord should always be called Id, and the other parameters should be CamelCased attributes of your data model. 

    * All parameters will be available as lower-case, underscored functions, e.g. -module(foo, [Id, TheText]) will generate the getter functions id() and the_text(), and the setters id(NewId) and the_text(NewText). Note that setters do not save the BossRecord.

    * To auto-generate an ID, pass the atom 'id' as the first parameter to "new".

    * Call "new" with strings for all other parameters

    * Parameters that end in "Time" (e.g., CreationTime, UpdateTime) should be passed either erlang:now() or a datetime tuple.

Generated instance functions of a BossRecord include:

    save() -> BossRecord

        Saves the BossRecord to the database. The returned record will have an auto-generated ID if the record's ID was set to 'id'.

    attribute_names() -> [atom()]

        A list of the lower-case BossRecord parameters, e.g. [id, the_text].

    attributes() -> [{atom(), string() | undefined}]

        A proplist of the BossRecord parameters and their values.

    attributes(Proplist) -> BossRecord

        Set multiple record attributes at once. Does not save the record.

    incr(CounterName::atom()) -> integer()

        Atomically increment CounterName by 1. Requires at least one "-counter" attribute, see below.

    incr(CounterName::atom(), Increment::integer()) -> integer()

        Atomically increment CounterName by Increment. Requires at least one "-counter" attribute, see below.

    reset(CounterName::atom()) -> 0

        Reset the value of CounterName to 0. Requires at least one "-counter" attribute, see below.


Special associations are generated from the following module attributes:

    -belongs_to(foo).

        Requires a matching FooId in the parameter list. Adds a function foo() which returns the foo BossRecord with ID equal to the current BossRecord's FooId.

    -has_many(bars).

        Generates a function bars() which returns a list all "bar" BossRecords with FooId equal to this BossRecord's ID.

The two above attributes work similar to belongs_to and has_many in Rails. More special attributes:

    -has_up_to({Limit::integer(), bars}).
    -has_up_to({Limit::integer(), bars, Sort::atom()}).
    -has_up_to({Limit::integer(), bars, Sort::atom(), SortOrder}).

        SortOrder = str_ascending | str_descending | num_ascending | num_descending

        Generates a function bars() which returns a list of up to Limit "bar" BossRecords with FooId equal to this BossRecord's ID. Optional args:

        Sort:       the record attribute to sort the association on
        SortOrder:  how to sort the association

        Note that Time attributes are stored internally as integers, so sort them with num_ascending or num_descending.

    -counter(foo_counter).

        Generates a function foo_counter() which returns the value of the counter, initialized to zero. Each BossRecord may have an unlimited number of counters. Manipulate the counters with "reset" and "incr" above.

SPECIAL NOTE: Everything in the Model directory will be compiled as a BossRecord rather than as a regular Erlang module; you don't need to do or declare anything special. The example at the end of this file should make things clear.


== The View Directory: ErlyDTL Templates ==

All files in the View subdirectories are Django Templates. The files should end in .html. Each file is associated with a function of a particular controller (see below). Variables referred to in the View files may be BossRecords, binaries, strings, integers, iolists, gb_hashes, proplists, dicts, or old-fashioned parameterized modules. See the ErlyDTL page for examples and details of how templates work:

    http://code.google.com/p/erlydtl/


== The Controller Directory: The BossController API ==

Each URL is associated with a function of a controller. Each controller module should end with "_controller.erl". The URL /foo/bar will call the function foo_controller:bar/1. The one and only argument passed to the function is a Mochiweb request object. The function should return with one of the following:

    ok

        The template will be rendered without any variables.

    {ok, Variables::proplist()}

        Variables will be passed into the associated ErlyDTL template.

    {ok, Variables::proplist(), Headers::proplist()}
    
        Variables will be passed into the associated ErlyDTL template. Headers are HTTP headers you want to set, but the only allowed one right now is Content-Type (defaults to "text/html").

    {redirect, Location::string()}

        Perform a 302 HTTP redirect to Location.

    {redirect, Location::string(), Headers::proplist()}

        Perform a 302 HTTP redirect to Location and set additional HTTP Headers.

    {action_other, OtherLocation}

        OtherLocation = {ControllerName::atom(), ActionName::atom()}

        Execute the specified controller action, but without performing an HTTP redirect.

    {render_other, OtherLocation}

        OtherLocation = {ControllerName::atom(), ActionName::atom()}

        Render the view from OtherLocation, but don't actually execute the associated controller action.

    {render_other, OtherLocation, Variables}

        OtherLocation = {ControllerName::atom(), ActionName::atom()}

        Render the view from OtherLocation using Variables, but don't actually execute the associated controller action.


If a controller exports a function called before_filter/1, then before executing an action in the controller, Chicago Boss will pass the action name as an atom to before_filter/1. before_filter should return a fun that takes a Mochiweb request object as its only argument and (in turn) returns one of the following:

    ok

        Execute the original action as normal

    {ok, ExtraInfo}

        Execute the original action, but pass ExtraInfo as the second argument to the controller function (the first argument is still the Mochiweb request object).

    {redirect, Location}

        Perform a 302 redirect to Location (a string).

Probably most common before_filter looks like:

    before_filter(_) ->
        fun user_controller:require_login/1.



Useful functions in the Mochiweb request object include:

    get_qs_value( Key::string() ) -> string() | undefined

        Get the value of a given query string parameter (e.g. "?id=1234")

    get_post_value( Key::string() ) -> string() | undefined

        Get the value of a given POST parameter

    get_header_value( Key::string() ) -> string() | undefined

        Get the value of a given HTTP request header

    get_cookie_value( Key::string() ) -> string() | undefined

        Get the value of a given cookie.

    get(method) -> atom()

        Get the HTTP method ('GET', 'POST', etc.)


== Querying the Database: BossDB ==

To interact more directly with the database, the following functions are available:

    boss_db:find( Id::string() ) -> BossRecord

        Find a BossRecord with the specified Id.

    boss_db:find( Type::atom(), Conditions, Max::integer() ) -> [ BossRecord ]
    boss_db:find( Type::atom(), Conditions, Max::integer(), Skip::integer() ) -> [ BossRecord ]
    boss_db:find( Type::atom(), Conditions, Max::integer(), Skip::integer(), Sort::atom(), ) -> [ BossRecord ]
    boss_db:find( Type::atom(), Conditions, Max::integer(), Skip::integer(), Sort::atom(), SortOrder ) -> [ BossRecord ]

        Conditions = [{Attribute::atom(), Value::string()}]
        SortOrder = str_ascending | str_descending | num_ascending | num_descending

        Query for a list of up to Max number of BossRecords of type Type that exactly match all of the given conditions (attribute = value). Optional args:

        Skip:       number of search results to skip
        Sort:       the record attribute to sort on
        SortOrder:  how to sort the results

        Note that Time attributes are stored internally as integers, so sort them with num_ascending or num_descending.

    boss_db:delete( Id::string() ) -> ok | {error, Reason}

        Delete the BossRecord with the given Id.

    boss_db:save_record(BossRecord) -> SavedBossRecord

        Save (that is, create or update) the given BossRecord in the database.

    boss_db:counter( Id::string() ) -> integer()

        Treat the record associated with Id as a counter and return its value. Returns 0 if the record does not exist, so to reset a counter just use "delete".

    boss_db:incr( Id::string() ) -> integer()

        Treat the record associated with Id as a counter and atomically increment its value.

    boss_db:incr( Id::string(), Increment::integer() ) -> integer()

        Treat the record associated with Id as a counter and atomically increment its value by Increment.



= A DECEPTIVELY SIMPLE EXAMPLE =

Model:

    Model/blog_post.erl:

        -module(blog_post, [Id, Title, Text, AuthorId]).
        -compile(export_all).
        -belongs_to(author).

    Model/author.erl:

        -module(author, [Id, Name]).
        -compile(export_all).
        -has_up_to({100, blog_posts}).

        number_of_blog_posts() ->
            length(blog_posts()).

Controller:

    Controller/blog_post_controller.erl:

        -module(blog_post_controller).
        -compile(export_all).

        generate_and_show(Req) ->
            Author = author:new(id, <<"My Name">>),
            SavedAuthor = Author:save(),
            BlogPost = blog_post:new(id, <<"My Title">>, <<"My Text">>, SavedAuthor:id()),
            {ok, [{blog_post, BlogPost:save()}]}.

View:

    View/blog_post/generate_and_show.html:

        <h1>{{ blog_post.title }}</h1>

        By {{ blog_post.author.name }} (Post # {{ blog_post.author.number_of_blog_posts }})
    
        {{ blog_post.title }}
